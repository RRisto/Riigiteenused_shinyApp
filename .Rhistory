#kui selle kanali kohta stati pole, anna vastuseks null
if(length(id)<7) {
tulem=NULL
} else {
#meldime andmed kitsaks
tulem=melt(sub, id=id)
#muudan variable nime ära, mis on kanalispets, muidu ei saa rbindida
names(tulem)=c("identifikaator", "tegevusvaldkond", "tyyp", "ministeerium", "allasutus",
"makse", "link",  "variable",
"value")
}
tulem
}
#abifunktsioon andmete sisse lugemiseks
korrastaja=function(andmed, eemalda) {
library(reshape2)
#eemalda - mis osa columnite nimedest tuleb eemdalda
names(andmed)=gsub(pattern=eemalda,"" ,names(andmed))
#kanalite lõikes meldime
veeb=meltimine("Veebileht / portaal.", data=andmed)
iseteen=meltimine("E-iseteenindus.", data=andmed)
eesti=meltimine("Eesti.ee.", data=andmed)
nuti=meltimine("Nutirakendus.", data=andmed)
digitv=meltimine("Digitelevisioon.", data=andmed)
epost=meltimine("E-post.", data=andmed)
sms=meltimine("Tekstisõnum.", data=andmed)
telefon=meltimine("Telefon.", data=andmed)
faks=meltimine("Faks.", data=andmed)
post=meltimine("Post.", data=andmed)
lett=meltimine("Letiteenus büroos.", data=andmed) #võib muutuda! vaja ka gsubi siis lisada
kodus=meltimine("Kliendi juures.", data=andmed)
#rbindime
koos=rbind(veeb, iseteen, eesti, nuti, digitv, epost, sms, telefon, faks,
post, lett, kodus)
#leiame kanali ja näitaja
#kanal <- strsplit(as.character(koos$variable), split ="\\.\\w{1,}$")
#stati saamiseks eemaldame punktid kanali nimedest
koos$variable=gsub(".ee.", ".", as.character(koos$variable), fixed=T)
koos$variable=gsub("Letiteenus büroos", "Letiteenus", as.character(koos$variable), fixed=T)
koos$variable=gsub("E-iseteenindus", "Eiseteenindus", as.character(koos$variable), fixed=T)
koos$variable=gsub("E-post", "Epost", as.character(koos$variable), fixed=T)
koos$variable=gsub("Veebileht / portaal", "Veebileht", as.character(koos$variable), fixed=T)
stat=gsub("Kliendi juures", "Kliendijuures", as.character(koos$variable), fixed=T)
#lõikame punktini asja maha
stat <- strsplit(stat, split ="\\.")
#teeme df-ks
df=as.data.frame(stat)
#transponeerime
df=as.data.frame(t(df))
#lisame algsesse andmestikku
koos$kanal=df[,2]
koos$naitaja=df[,3]
#viskame välja tühjad read, kus pole linki
koos$link=as.factor(koos$link)
# koos=koos[!is.na(koos$link),]
koos$value=as.numeric(as.character(koos$value))
koos
}
#andmete download
andmedSisse=function() {
#loeme andmed sisse
library(jsonlite)
library(data.table)
andmed=fromJSON(readLines("https://www.riigiteenused.ee/api/et/all"), flatten=T)
andmed=andmed["teenuste_kanalid_ja_moodikud"!="list()"]
andmedMoodik <- rbindlist(lapply(andmed[["teenuste_kanalid_ja_moodikud"]], function(x) {
as.list(unlist(x))
}), fill=TRUE)
andmed
}
#andmed pikaks
DataLong2=function(andmedLai) {
vars=names(andmedLai) %in% c("regulatsioon", "objectId", "eluarisyndmus", "kirjeldus",
"eeltingimus", "jareltingimus", "createdAt",
"updatedAt", "keel", "osakondyksus", "omanikunimi",
"omanikutelefon","omanikuemail",
"konfinfo", "seotuddokumendid", "seisund",
"muudatustvajav", "aegumisekpv", "funktsioon",
"veebiaadress")
#eemaldame muutujad
andmedLai=andmedLai[,!vars]
#aastate põhjal teeme andmed 2-ks (kui aastaid rohkem siis vastavalt sellele
#arv muutub)
andmedLai2014=andmedLai[, !grepl("empty.|2011.", names(andmedLai))]
andmedLai2011=andmedLai[, !grepl("empty.|2014.", names(andmedLai))]
andmedLaiEmpty=andmedLai[, !grepl("2014.|2011.", names(andmedLai))]
puhas2014=korrastaja(andmedLai2014, "2014.")
puhasEmpty=korrastaja(andmedLaiEmpty, "empty.")
puhas2011=korrastaja(andmedLai2011, "2011.")
#paneme andme kokku
andmedPikk=rbind(puhas2014, puhas2011,puhasEmpty)
andmedPikk
}
andmedLai=andmedSisse()
andmed=DataLong2(andmedLai)
andmed[andmed$identifikaator=="AGRI-002", "link"]
write.table(andmed, "proov.csv", sep=";")
andmed=andmed[!is.na(andmed$link),]
write.table(andmed, "proov2.csv", sep=";")
shiny::runApp()
shiny::runApp()
meltimine=function(kanal, data) {
library(reshape2)
#leiame ainult seda kanalit puudutavad muutujad
sub=data[, grepl(paste(kanal, "|identifikaator|ministeerium|allasutus|tegevusvaldkond|teenusetyyp|makse", sep=""), names(data))]
#määran id-d, mis meltimisel meltimata jäävad
id=grep(c("identifikaator|ministeerium|allasutus|tegevusvaldkond|teenusetyyp|makse|link"), names(sub), value=T)
#kui selle kanali kohta stati pole, anna vastuseks null
if(length(id)<7) {
tulem=NULL
} else {
#meldime andmed kitsaks
tulem=melt(sub, id=id)
#muudan variable nime ära, mis on kanalispets, muidu ei saa rbindida
names(tulem)=c("identifikaator", "tegevusvaldkond", "tyyp", "ministeerium", "allasutus",
"makse", "link",  "variable",
"value")
}
tulem
}
#abifunktsioon andmete sisse lugemiseks
korrastaja=function(andmed, eemalda) {
library(reshape2)
#eemalda - mis osa columnite nimedest tuleb eemdalda
names(andmed)=gsub(pattern=eemalda,"" ,names(andmed))
#kanalite lõikes meldime
veeb=meltimine("Veebileht / portaal.", data=andmed)
iseteen=meltimine("E-iseteenindus.", data=andmed)
eesti=meltimine("Eesti.ee.", data=andmed)
nuti=meltimine("Nutirakendus.", data=andmed)
digitv=meltimine("Digitelevisioon.", data=andmed)
epost=meltimine("E-post.", data=andmed)
sms=meltimine("Tekstisõnum.", data=andmed)
telefon=meltimine("Telefon.", data=andmed)
faks=meltimine("Faks.", data=andmed)
post=meltimine("Post.", data=andmed)
lett=meltimine("Letiteenus büroos.", data=andmed) #võib muutuda! vaja ka gsubi siis lisada
kodus=meltimine("Kliendi juures.", data=andmed)
#rbindime
koos=rbind(veeb, iseteen, eesti, nuti, digitv, epost, sms, telefon, faks,
post, lett, kodus)
#leiame kanali ja näitaja
#kanal <- strsplit(as.character(koos$variable), split ="\\.\\w{1,}$")
#stati saamiseks eemaldame punktid kanali nimedest
koos$variable=gsub(".ee.", ".", as.character(koos$variable), fixed=T)
koos$variable=gsub("Letiteenus büroos", "Letiteenus", as.character(koos$variable), fixed=T)
koos$variable=gsub("E-iseteenindus", "Eiseteenindus", as.character(koos$variable), fixed=T)
koos$variable=gsub("E-post", "Epost", as.character(koos$variable), fixed=T)
koos$variable=gsub("Veebileht / portaal", "Veebileht", as.character(koos$variable), fixed=T)
stat=gsub("Kliendi juures", "Kliendijuures", as.character(koos$variable), fixed=T)
#lõikame punktini asja maha
stat <- strsplit(stat, split ="\\.")
#teeme df-ks
df=as.data.frame(stat)
#transponeerime
df=as.data.frame(t(df))
#lisame algsesse andmestikku
koos$kanal=df[,2]
koos$naitaja=df[,3]
#viskame välja tühjad read, kus pole linki
koos$link=as.factor(koos$link)
# koos=koos[!is.na(koos$link),]
koos$value=as.numeric(as.character(koos$value))
koos
}
#andmete download
andmedSisse=function() {
#loeme andmed sisse
library(jsonlite)
library(data.table)
andmed=fromJSON(readLines("https://www.riigiteenused.ee/api/et/all"), flatten=T)
andmed=andmed["teenuste_kanalid_ja_moodikud"!="list()"]
andmedMoodik <- rbindlist(lapply(andmed[["teenuste_kanalid_ja_moodikud"]], function(x) {
as.list(unlist(x))
}), fill=TRUE)
andmed
}
#andmed pikaks
DataLong2=function(andmedLai) {
vars=names(andmedLai) %in% c("regulatsioon", "objectId", "eluarisyndmus", "kirjeldus",
"eeltingimus", "jareltingimus", "createdAt",
"updatedAt", "keel", "osakondyksus", "omanikunimi",
"omanikutelefon","omanikuemail",
"konfinfo", "seotuddokumendid", "seisund",
"muudatustvajav", "aegumisekpv", "funktsioon",
"veebiaadress")
#eemaldame muutujad
andmedLai=andmedLai[,!vars]
#aastate põhjal teeme andmed 2-ks (kui aastaid rohkem siis vastavalt sellele
#arv muutub)
andmedLai2014=andmedLai[, !grepl("empty.|2011.", names(andmedLai))]
andmedLai2011=andmedLai[, !grepl("empty.|2014.", names(andmedLai))]
andmedLaiEmpty=andmedLai[, !grepl("2014.|2011.", names(andmedLai))]
puhas2014=korrastaja(andmedLai2014, "2014.")
puhasEmpty=korrastaja(andmedLaiEmpty, "empty.")
puhas2011=korrastaja(andmedLai2011, "2011.")
#paneme andme kokku
andmedPikk=rbind(puhas2014, puhas2011,puhasEmpty)
andmedPikk
}
andmedLai=andmedSisse()
andmed=DataLong2(andmedLai)
andmed=andmed[!is.na(andmed$link),]
andmed[andmed$identifikaator=="AGRI-002", "link"]
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
andmed=readRDS("./andmed/2016-02-05_andmedPikk.rds")
write.table(andmed, "proov.csv")
dnorm(x=1, sd=2, mean=1)
x=dnorm(x=1, sd=2, mean=1)
y=dnorm(x=1, sd=2, mean=2)
x/(x+y)
y=dnorm(x=1, sd=3, mean=2)
x=dnorm(x=1, sd=3, mean=1)
x/(x+y)
a=c(-7,-5, -3, -3, 1, 6, 7, 13, 15, 16, 20, 21)
var(a)
sd(a)
a
class(a)
mean(a)
mean(a[5:])
a[5:]
a[5]
a[5:]
a[5:_]
length(a)
mean(a[5:12])
var(a[5:12])
sd(a[5:12])
sclaeda=scale(a)
sclaeda
library("devtools")
install_github("laurii/opendata.ee")
library(opendata.ee)
proov=data_riigiteenused()
View(proov)
str(proov)
require(rjson)
df <- jsonlite::fromJSON("https://www.riigiteenused.ee/api/et/all", flatten=T)
View(df)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
Sys.time()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
server <- function(input, output) {
output$plot <- renderPlot({
input$goPlot # Re-run when button is clicked
# Create 0-row data frame which will be used to store data
dat <- data.frame(x = numeric(0), y = numeric(0))
withProgress(message = 'Making plot', value = 0, {
# Number of times we'll go through the loop
n <- 10
for (i in 1:n) {
# Each time through the loop, add another row of data. This is
# a stand-in for a long-running computation.
dat <- rbind(dat, data.frame(x = rnorm(1), y = rnorm(1)))
# Increment the progress bar, and update the detail text.
incProgress(1/n, detail = paste("Doing part", i))
# Pause for 0.1 seconds to simulate a long computation.
Sys.sleep(0.1)
}
})
plot(dat$x, dat$y)
})
}
ui <- shinyUI(basicPage(
plotOutput('plot', width = "300px", height = "300px"),
actionButton('goPlot', 'Go plot')
))
shinyApp(ui = ui, server = server)
shiny::runApp()
shiny::runApp()
shiny::runApp()
compute_data <- function(updateProgress = NULL) {
# Create 0-row data frame which will be used to store data
dat <- data.frame(x = numeric(0), y = numeric(0))
for (i in 1:10) {
Sys.sleep(0.25)
# Compute new row of data
new_row <- data.frame(x = rnorm(1), y = rnorm(1))
# If we were passed a progress update function, call it
if (is.function(updateProgress)) {
text <- paste0("x:", round(new_row$x, 2), " y:", round(new_row$y, 2))
updateProgress(detail = text)
}
# Add the new row of data
dat <- rbind(dat, new_row)
}
dat
}
server <- function(input, output) {
output$table <- renderTable({
input$goTable
# Create a Progress object
progress <- shiny::Progress$new()
progress$set(message = "Computing data", value = 0)
# Close the progress when this reactive exits (even if there's an error)
on.exit(progress$close())
# Create a callback function to update progress.
# Each time this is called:
# - If `value` is NULL, it will move the progress bar 1/5 of the remaining
#   distance. If non-NULL, it will set the progress to that value.
# - It also accepts optional detail text.
updateProgress <- function(value = NULL, detail = NULL) {
if (is.null(value)) {
value <- progress$getValue()
value <- value + (progress$getMax() - value) / 5
}
progress$set(value = value, detail = detail)
}
# Compute the new data, and pass in the updateProgress function so
# that it can update the progress indicator.
compute_data(updateProgress)
})
}
ui <- shinyUI(basicPage(
tableOutput('table'),
actionButton('goTable', 'Go table')
))
shinyApp(ui = ui, server = server)
shiny::runApp()
shiny::runApp()
shiny::runApp()
install.packages("shinyjs")
library(shinyjs)
appCSS <- "
#loading-content {
position: absolute;
background: #000000;
opacity: 0.9;
z-index: 100;
left: 0;
right: 0;
height: 100%;
text-align: center;
color: #FFFFFF;
}
"
shinyApp(
ui = fluidPage(
useShinyjs(),
inlineCSS(appCSS),
# Loading message
div(
id = "loading-content",
h2("Loading...")
),
# The main app code goes here
div(
id = "app-content",
p("This is a simple example of a Shiny app with a loading screen."),
p("You can view the source code",
a(href = "https://github.com/daattali/shiny-server/blob/master/loading-screen",
"on GitHub")
)
)
),
server = function(input, output, session) {
# Simulate work being done for 1 second
Sys.sleep(1)
# Hide the loading message when the rest of the server function has executed
hide(id = "loading-content", anim = TRUE, animType = "fade")
}
)
library(shinyjs)
appCSS <- "
#loading-content {
position: absolute;
background: #000000;
opacity: 0.9;
z-index: 100;
left: 0;
right: 0;
height: 100%;
text-align: center;
color: #FFFFFF;
}
"
shinyApp(
ui = fluidPage(
useShinyjs(),
inlineCSS(appCSS),
# Loading message
div(
id = "loading-content",
h2("Loading...")
),
# The main app code goes here
div(
id = "app-content",
p("This is a simple example of a Shiny app with a loading screen."),
p("You can view the source code",
a(href = "https://github.com/daattali/shiny-server/blob/master/loading-screen",
"on GitHub")
)
)
),
server = function(input, output, session) {
# Simulate work being done for 1 second
Sys.sleep(1)
# Hide the loading message when the rest of the server function has executed
hide(id = "loading-content", anim = TRUE, animType = "fade")
}
)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
Sys.time()
proov=Sys.time()
str(proov)
proov+1
proov360
proov+360
proov+3600
60*60*3
proov+10800
60*60*2
proov+7200
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
Sys.time()
shiny::runApp()
9/1382
View(server)
shiny::runApp()
shiny::runApp()
install.packages("shiny")
install.packages("shiny")
shiny::runApp()
install.packages("Rcpp")
shiny::runApp()
install.packages("curl")
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
andmedLai=riigiteenused::andmedSisse("https://www.riigiteenused.ee/api/et/all")
shiny::runApp()
shiny::runApp()
